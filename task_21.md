# Решение задания 21


**Наследование реализации** отличается от наследования конкретизацией в первую очередь тем, что при таком наследовании делается четкий акцент на использовании уже готовой реализации родительского класса. Например, вызов в инициализаторе класса- потомка инициализатора класса- предка, или же вызов метода предка в методе потомка.

Пусть, делаем Шахматы - 2. Продолжение повсеместно известной игры. Имеется у нас уже реализованный класс Конь, который ходит буквой "Г", в шахматах 2 у этого коня будет еще одна абилка- он будет в радиусе одной клетки наносить урон.
``` python
class Horse:
    def __init__(self, **kwargs):
        for key in kwargs:
            self.__dict__(key) = kwargs[key]

    def move(self, destination):
        pass


class SuperHorse(Horse):
    def __init__(self, **kwargs):
        super().__init__(kwargs)

    def move(self, destination):
        super().move(destination)
        self.stomp_hit()

    def stomp_hit(slef):
        pass
```

**Льготное наследование** похоже на применение швейцарского ножа. Класс- предок это нож, а классы- потомки это та или иная приспособа из этого самого ножа, подходящая под конкретную ситуацию.

Например, существует класс "Мега Такси Всё включено", в этом классе есть метод, предлагающий пользователю какой- то напиток, а самих этих напитков может быть десяток. Наследник этого класса будет конкретизировать напиток, который будет предложен пользователю такси.

``` python
class Taxi:
    drinks = {...}

    def __init__(self):
        ...

    def offer_drink(self):
        drink = Taxi.drinks[...]
        ...

class MohitoTaxi():
    drinks = {'mohito' : ...}

    ...

    def offer_drink(self):
        drink = MohitoTaxi.drinks['mohito']
        ...
```
